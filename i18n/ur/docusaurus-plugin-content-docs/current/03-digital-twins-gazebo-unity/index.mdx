---
id: "digital-twins-gazebo-unity"
title: "Digital Twins: Gazebo & Unity"
sidebar_label: "3. Digital Twins"
sidebar_position: 1
keywords:
  - digital twin
  - Gazebo
  - Gazebo Harmonic
  - Unity
  - simulation
  - SDF
  - URDF
  - ros_gz
description: "Creating digital twins for robots using Gazebo Harmonic and Unity simulation environments."
---

import { Quiz, CodePlayground, CollapsibleSection } from '@site/src/components';

# Digital Twins: Gazebo & Unity

A digital twin is a virtual replica of a physical robot that mirrors its behavior in simulation. Digital twins enable safe development, testing, and validation of robot behaviors before deployment to hardware. This chapter covers creating simulation environments with Gazebo Harmonic and bridging them to ROS 2.

## Learning Objectives

By the end of this chapter, you will be able to:

1. **[LO-01]**: Install and configure Gazebo Harmonic for robot simulation on Ubuntu 22.04 (Bloom's: Apply)
2. **[LO-02]**: Create robot models using SDF format with links, joints, and collision geometry (Bloom's: Apply)
3. **[LO-03]**: Configure simulated sensors including cameras, LiDAR, and IMU using Gazebo plugins (Bloom's: Apply)
4. **[LO-04]**: Bridge Gazebo topics to ROS 2 using ros_gz for bidirectional communication (Bloom's: Apply)
5. **[LO-05]**: Diagnose common simulation failures including physics instability, timing issues, and sensor artifacts (Bloom's: Analyze)

---

## System Architecture

A digital twin simulation consists of three main layers: the physics engine, the robot model, and the ROS 2 interface.

<!-- Architecture diagram placeholder - to be added during chapter authoring -->

**Core Components**:

| Component | Purpose | Technology |
|-----------|---------|------------|
| Physics Engine | Simulate dynamics, collisions, gravity | Gazebo (DART, Bullet, ODE) |
| World Model | Define environment, lighting, objects | SDF (Simulation Description Format) |
| Robot Model | Define robot geometry, joints, sensors | SDF or URDF |
| Sensor Plugins | Generate simulated sensor data | gz-sensors library |
| ROS Bridge | Connect simulation to ROS 2 | ros_gz package |

**Data Flow**:

```
┌─────────────────────────────────────────────────────────┐
│                    Gazebo Simulation                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────────────────┐   │
│  │  World   │  │  Robot   │  │    Sensor Plugins    │   │
│  │  Model   │  │  Model   │  │ Camera│LiDAR│IMU│... │   │
│  └──────────┘  └──────────┘  └──────────────────────┘   │
│                        │                                 │
│              gz-transport topics                         │
└────────────────────────┼────────────────────────────────┘
                         │
              ┌──────────▼──────────┐
              │    ros_gz_bridge    │
              └──────────┬──────────┘
                         │
              ┌──────────▼──────────┐
              │    ROS 2 Topics     │
              │ /camera/image       │
              │ /scan               │
              │ /cmd_vel            │
              └─────────────────────┘
```

---

## Gazebo Harmonic Setup

Gazebo Harmonic (gz-sim 8) is the recommended simulator for ROS 2 Humble and Iron. It replaces Gazebo Classic with improved performance, modularity, and ROS 2 integration.

### Installation

```bash
# Install Gazebo Harmonic on Ubuntu 22.04
sudo apt-get update
sudo apt-get install -y lsb-release wget gnupg

# Add Gazebo repository
sudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/gazebo-stable.list > /dev/null

# Install Gazebo Harmonic
sudo apt-get update
sudo apt-get install -y gz-harmonic

# Verify installation
gz sim --version
```

### ROS 2 Integration Packages

```bash
# Install ros_gz packages for ROS 2 Humble
sudo apt-get install -y ros-humble-ros-gz

# This installs:
# - ros_gz_bridge: Topic bridging
# - ros_gz_sim: Launch integration
# - ros_gz_image: Image transport bridge
```

### First Simulation

Launch an empty world to verify the installation:

```bash
# Start Gazebo with an empty world
gz sim empty.sdf

# Or with ROS 2 integration
ros2 launch ros_gz_sim gz_sim.launch.py gz_args:=empty.sdf
```

<CollapsibleSection title="Gazebo GUI Controls" variant="info">

**Navigation**:
- **Left-click + drag**: Rotate view
- **Right-click + drag**: Pan view
- **Scroll wheel**: Zoom in/out
- **Middle-click + drag**: Orbit around point

**Simulation Control**:
- **Play/Pause**: Start/stop physics
- **Step**: Advance one physics step
- **Reset**: Return to initial state

**Entity Selection**:
- **Left-click**: Select entity
- **Translate/Rotate tools**: Manipulate selected entity

</CollapsibleSection>

---

## SDF Model Creation

SDF (Simulation Description Format) is the native model format for Gazebo. It defines robot geometry, physics properties, joints, and sensors in XML.

### Basic Model Structure

```xml
<?xml version="1.0"?>
<sdf version="1.9">
  <model name="simple_robot">
    <!-- Base link (chassis) -->
    <link name="base_link">
      <!-- Visual geometry (what you see) -->
      <visual name="base_visual">
        <geometry>
          <box>
            <size>0.5 0.3 0.1</size>
          </box>
        </geometry>
        <material>
          <ambient>0.2 0.2 0.8 1</ambient>
          <diffuse>0.2 0.2 0.8 1</diffuse>
        </material>
      </visual>

      <!-- Collision geometry (physics interactions) -->
      <collision name="base_collision">
        <geometry>
          <box>
            <size>0.5 0.3 0.1</size>
          </box>
        </geometry>
      </collision>

      <!-- Inertial properties -->
      <inertial>
        <mass>5.0</mass>
        <inertia>
          <ixx>0.0417</ixx>
          <iyy>0.1042</iyy>
          <izz>0.1417</izz>
        </inertia>
      </inertial>
    </link>

    <!-- Left wheel -->
    <link name="left_wheel">
      <pose relative_to="base_link">0 0.2 -0.05 1.5708 0 0</pose>
      <visual name="wheel_visual">
        <geometry>
          <cylinder>
            <radius>0.05</radius>
            <length>0.02</length>
          </cylinder>
        </geometry>
        <material>
          <ambient>0.1 0.1 0.1 1</ambient>
        </material>
      </visual>
      <collision name="wheel_collision">
        <geometry>
          <cylinder>
            <radius>0.05</radius>
            <length>0.02</length>
          </cylinder>
        </geometry>
        <surface>
          <friction>
            <ode>
              <mu>1.0</mu>
              <mu2>1.0</mu2>
            </ode>
          </friction>
        </surface>
      </collision>
      <inertial>
        <mass>0.5</mass>
        <inertia>
          <ixx>0.0003</ixx>
          <iyy>0.0003</iyy>
          <izz>0.0006</izz>
        </inertia>
      </inertial>
    </link>

    <!-- Left wheel joint -->
    <joint name="left_wheel_joint" type="revolute">
      <parent>base_link</parent>
      <child>left_wheel</child>
      <axis>
        <xyz>0 0 1</xyz>
        <limit>
          <lower>-1.79769e+308</lower>
          <upper>1.79769e+308</upper>
        </limit>
      </axis>
    </joint>

    <!-- Differential drive plugin -->
    <plugin
      filename="gz-sim-diff-drive-system"
      name="gz::sim::systems::DiffDrive">
      <left_joint>left_wheel_joint</left_joint>
      <right_joint>right_wheel_joint</right_joint>
      <wheel_separation>0.4</wheel_separation>
      <wheel_radius>0.05</wheel_radius>
      <topic>cmd_vel</topic>
      <odom_topic>odom</odom_topic>
    </plugin>
  </model>
</sdf>
```

### Inertia Calculation

Accurate inertia values are critical for stable physics simulation. For common shapes:

**Box** (mass m, dimensions x, y, z):
```
Ixx = (1/12) * m * (y² + z²)
Iyy = (1/12) * m * (x² + z²)
Izz = (1/12) * m * (x² + y²)
```

**Cylinder** (mass m, radius r, length h):
```
Ixx = Iyy = (1/12) * m * (3r² + h²)
Izz = (1/2) * m * r²
```

**Sphere** (mass m, radius r):
```
Ixx = Iyy = Izz = (2/5) * m * r²
```

### Converting URDF to SDF

If you have an existing URDF model, convert it to SDF:

```bash
# Convert URDF to SDF
gz sdf -p robot.urdf > robot.sdf

# Or use the URDF directly in Gazebo (automatic conversion)
gz sim -r robot.urdf
```

---

## Sensor Simulation

Gazebo provides plugins for simulating common robot sensors. Sensors generate data published to gz-transport topics, which can be bridged to ROS 2.

### Camera Sensor

```xml
<link name="camera_link">
  <pose relative_to="base_link">0.2 0 0.1 0 0 0</pose>
  <sensor name="camera" type="camera">
    <always_on>true</always_on>
    <update_rate>30</update_rate>
    <camera>
      <horizontal_fov>1.047</horizontal_fov>
      <image>
        <width>640</width>
        <height>480</height>
        <format>R8G8B8</format>
      </image>
      <clip>
        <near>0.1</near>
        <far>100</far>
      </clip>
    </camera>
    <topic>camera/image</topic>
  </sensor>
</link>
```

### LiDAR Sensor

```xml
<link name="lidar_link">
  <pose relative_to="base_link">0.1 0 0.15 0 0 0</pose>
  <sensor name="lidar" type="gpu_lidar">
    <always_on>true</always_on>
    <update_rate>10</update_rate>
    <lidar>
      <scan>
        <horizontal>
          <samples>360</samples>
          <resolution>1</resolution>
          <min_angle>-3.14159</min_angle>
          <max_angle>3.14159</max_angle>
        </horizontal>
      </scan>
      <range>
        <min>0.1</min>
        <max>10.0</max>
        <resolution>0.01</resolution>
      </range>
    </lidar>
    <topic>scan</topic>
  </sensor>
</link>
```

### IMU Sensor

```xml
<link name="imu_link">
  <pose relative_to="base_link">0 0 0.05 0 0 0</pose>
  <sensor name="imu" type="imu">
    <always_on>true</always_on>
    <update_rate>100</update_rate>
    <imu>
      <angular_velocity>
        <x>
          <noise type="gaussian">
            <mean>0</mean>
            <stddev>0.01</stddev>
          </noise>
        </x>
        <y>
          <noise type="gaussian">
            <mean>0</mean>
            <stddev>0.01</stddev>
          </noise>
        </y>
        <z>
          <noise type="gaussian">
            <mean>0</mean>
            <stddev>0.01</stddev>
          </noise>
        </z>
      </angular_velocity>
      <linear_acceleration>
        <x>
          <noise type="gaussian">
            <mean>0</mean>
            <stddev>0.1</stddev>
          </noise>
        </x>
      </linear_acceleration>
    </imu>
    <topic>imu</topic>
  </sensor>
</link>
```

---

## ros_gz Bridge

The ros_gz_bridge connects Gazebo topics to ROS 2 topics, enabling bidirectional communication between simulation and robot software.

### Bridge Configuration

Create a YAML file to define topic mappings:

```yaml
# bridge_config.yaml
- ros_topic_name: "/cmd_vel"
  gz_topic_name: "/model/robot/cmd_vel"
  ros_type_name: "geometry_msgs/msg/Twist"
  gz_type_name: "gz.msgs.Twist"
  direction: ROS_TO_GZ

- ros_topic_name: "/odom"
  gz_topic_name: "/model/robot/odom"
  ros_type_name: "nav_msgs/msg/Odometry"
  gz_type_name: "gz.msgs.Odometry"
  direction: GZ_TO_ROS

- ros_topic_name: "/scan"
  gz_topic_name: "/lidar/scan"
  ros_type_name: "sensor_msgs/msg/LaserScan"
  gz_type_name: "gz.msgs.LaserScan"
  direction: GZ_TO_ROS

- ros_topic_name: "/camera/image_raw"
  gz_topic_name: "/camera/image"
  ros_type_name: "sensor_msgs/msg/Image"
  gz_type_name: "gz.msgs.Image"
  direction: GZ_TO_ROS

- ros_topic_name: "/imu"
  gz_topic_name: "/imu"
  ros_type_name: "sensor_msgs/msg/Imu"
  gz_type_name: "gz.msgs.IMU"
  direction: GZ_TO_ROS
```

### Launch File

```python
# launch/simulation.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare


def generate_launch_description():
    pkg_share = FindPackageShare('my_robot_sim')

    # World file
    world_file = PathJoinSubstitution([pkg_share, 'worlds', 'robot_world.sdf'])

    # Bridge config
    bridge_config = PathJoinSubstitution([pkg_share, 'config', 'bridge_config.yaml'])

    return LaunchDescription([
        # Launch Gazebo
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource([
                PathJoinSubstitution([
                    FindPackageShare('ros_gz_sim'),
                    'launch',
                    'gz_sim.launch.py'
                ])
            ]),
            launch_arguments={
                'gz_args': ['-r ', world_file],
            }.items()
        ),

        # Launch bridge
        Node(
            package='ros_gz_bridge',
            executable='parameter_bridge',
            arguments=['--ros-args', '-p', 'config_file:=' + bridge_config],
            output='screen'
        ),

        # Spawn robot
        Node(
            package='ros_gz_sim',
            executable='create',
            arguments=[
                '-name', 'robot',
                '-file', PathJoinSubstitution([pkg_share, 'models', 'robot.sdf']),
                '-x', '0', '-y', '0', '-z', '0.1'
            ],
            output='screen'
        ),
    ])
```

### Manual Bridge Commands

For quick testing, bridge topics manually:

```bash
# Bridge velocity commands (ROS 2 -> Gazebo)
ros2 run ros_gz_bridge parameter_bridge \
  /cmd_vel@geometry_msgs/msg/Twist@gz.msgs.Twist

# Bridge laser scan (Gazebo -> ROS 2)
ros2 run ros_gz_bridge parameter_bridge \
  /scan@sensor_msgs/msg/LaserScan[gz.msgs.LaserScan

# Bridge camera (Gazebo -> ROS 2)
ros2 run ros_gz_bridge parameter_bridge \
  /camera/image_raw@sensor_msgs/msg/Image[gz.msgs.Image
```

---

## Practical Implementation

### Complete Simulation Package Structure

```
my_robot_sim/
├── CMakeLists.txt
├── package.xml
├── config/
│   └── bridge_config.yaml
├── launch/
│   └── simulation.launch.py
├── models/
│   └── robot/
│       ├── model.config
│       └── model.sdf
├── worlds/
│   └── warehouse.sdf
└── rviz/
    └── simulation.rviz
```

### Spawning Models Programmatically

```python
#!/usr/bin/env python3
"""
Spawn robot models in Gazebo programmatically.

Requirements:
- ROS 2 Humble
- ros_gz_sim package

Run with:
  ros2 run my_robot_sim spawn_robot
"""

import rclpy
from rclpy.node import Node
from ros_gz_interfaces.srv import SpawnEntity
from geometry_msgs.msg import Pose


class RobotSpawner(Node):
    """Spawns robot models in Gazebo simulation."""

    def __init__(self):
        super().__init__('robot_spawner')

        self.client = self.create_client(SpawnEntity, '/world/default/create')

        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for spawn service...')

    def spawn_robot(self, name: str, sdf_path: str, x: float, y: float, z: float):
        """Spawn a robot at the specified position."""
        request = SpawnEntity.Request()
        request.name = name
        request.xml = open(sdf_path).read()

        request.initial_pose = Pose()
        request.initial_pose.position.x = x
        request.initial_pose.position.y = y
        request.initial_pose.position.z = z

        future = self.client.call_async(request)
        rclpy.spin_until_future_complete(self, future)

        if future.result().success:
            self.get_logger().info(f'Spawned {name} at ({x}, {y}, {z})')
        else:
            self.get_logger().error(f'Failed to spawn {name}')


def main(args=None):
    rclpy.init(args=args)
    spawner = RobotSpawner()

    spawner.spawn_robot('robot1', '/path/to/robot.sdf', 0.0, 0.0, 0.1)
    spawner.spawn_robot('robot2', '/path/to/robot.sdf', 2.0, 0.0, 0.1)

    spawner.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Controlling the Simulated Robot

```python
#!/usr/bin/env python3
"""
Control a simulated robot using keyboard teleop.
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import sys
import termios
import tty


class KeyboardTeleop(Node):
    """Keyboard teleoperation for simulated robot."""

    def __init__(self):
        super().__init__('keyboard_teleop')

        self.publisher = self.create_publisher(Twist, '/cmd_vel', 10)

        self.linear_speed = 0.5
        self.angular_speed = 1.0

        self.get_logger().info('Keyboard Teleop Started')
        self.get_logger().info('Use WASD to move, Q to quit')

    def get_key(self):
        """Get a single keypress."""
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

    def run(self):
        """Main teleop loop."""
        twist = Twist()

        while True:
            key = self.get_key()

            if key == 'w':
                twist.linear.x = self.linear_speed
                twist.angular.z = 0.0
            elif key == 's':
                twist.linear.x = -self.linear_speed
                twist.angular.z = 0.0
            elif key == 'a':
                twist.linear.x = 0.0
                twist.angular.z = self.angular_speed
            elif key == 'd':
                twist.linear.x = 0.0
                twist.angular.z = -self.angular_speed
            elif key == ' ':
                twist.linear.x = 0.0
                twist.angular.z = 0.0
            elif key == 'q':
                break
            else:
                continue

            self.publisher.publish(twist)


def main(args=None):
    rclpy.init(args=args)
    teleop = KeyboardTeleop()
    teleop.run()
    teleop.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

---

## Common Failure Modes

### Failure Mode 1: Physics Instability

**Symptom**: Robot jitters, explodes, or flies away unexpectedly.

**Cause**: Incorrect inertia values, interpenetrating collision geometries, or physics step size too large.

**Resolution**:
1. Verify inertia calculations match actual mass and geometry
2. Ensure collision geometries don't overlap at spawn
3. Reduce physics step size: `<physics><max_step_size>0.001</max_step_size></physics>`
4. Add damping to joints to absorb energy

**Prevention**: Use mesh inspection tools to verify collision geometry. Start with simplified collision shapes (boxes, cylinders) before using complex meshes.

---

### Failure Mode 2: ros_gz Bridge Not Receiving Messages

**Symptom**: ROS 2 topics exist but receive no data; Gazebo topics show data flowing.

**Cause**: Topic name mismatch, type mismatch, or bridge direction incorrect.

**Resolution**:
1. List Gazebo topics: `gz topic -l`
2. Echo Gazebo topic: `gz topic -e -t /topic_name`
3. Verify exact topic names match in bridge config
4. Check bridge direction (GZ_TO_ROS vs ROS_TO_GZ)
5. Ensure message types are compatible

**Prevention**: Test bridges individually before combining. Use verbose bridge output for debugging.

---

### Failure Mode 3: Sensor Data Lag

**Symptom**: Sensor data arrives late; robot reacts to old information.

**Cause**: Simulation running slower than real-time; sensor update rate too high; system overloaded.

**Resolution**:
1. Check real-time factor: `gz stats`
2. Reduce sensor update rates
3. Simplify world geometry
4. Use GPU-accelerated sensors (gpu_lidar, gpu_ray)
5. Reduce camera resolution

**Prevention**: Monitor simulation performance during development. Design for worst-case compute availability.

---

### Failure Mode 4: Model Not Spawning

**Symptom**: Spawn command succeeds but model not visible; no errors shown.

**Cause**: Model spawned underground, at wrong scale, or with invalid SDF.

**Resolution**:
1. Verify spawn Z coordinate places model above ground
2. Check model scale in SDF (units are meters)
3. Validate SDF: `gz sdf -k model.sdf`
4. Check Gazebo console for warnings
5. Try spawning in empty world first

**Prevention**: Always validate SDF files before use. Use consistent coordinate frames.

---

### Failure Mode 5: Wheel Slip and Drift

**Symptom**: Robot slides sideways; wheels spin without moving robot.

**Cause**: Friction coefficients too low; wheel collision geometry incorrect; contact not detected.

**Resolution**:
1. Increase friction coefficients (mu, mu2) in collision surface
2. Use cylinder collision for wheels, not mesh
3. Ensure wheel contacts ground plane
4. Check that ground plane has friction defined

**Prevention**: Use proven friction values (mu=1.0 for rubber on concrete). Test drive behavior early.

---

## Hardware and Compute Requirements

| Requirement | Minimum | Recommended |
|-------------|---------|-------------|
| Operating System | Ubuntu 22.04 LTS | Ubuntu 22.04 LTS |
| CPU | 4 cores, 2.5 GHz | 8 cores, 3.5 GHz |
| RAM | 8 GB | 16 GB |
| GPU | None (software rendering) | NVIDIA GTX 1060+ |
| Storage | 15 GB free | 30 GB free |
| Display | 1920x1080 | 2560x1440 |

**GPU Acceleration**: For sensor-heavy simulations (multiple cameras, LiDAR), an NVIDIA GPU with CUDA support significantly improves performance. Install NVIDIA drivers and verify with:

```bash
nvidia-smi
gz sim --render-engine ogre2
```

---

## Summary

Digital twins provide a safe and efficient environment for developing robot behaviors. This chapter covered the complete workflow for creating simulated robots with Gazebo Harmonic:

**Gazebo Harmonic** is the recommended simulator for ROS 2, offering improved performance and native integration through ros_gz packages.

**SDF Models** define robot geometry, physics properties, and sensors in XML format. Accurate inertia values and collision geometry are essential for stable simulation.

**Sensor Plugins** generate simulated camera images, LiDAR scans, and IMU data. Configure update rates and noise models to match real sensor characteristics.

**ros_gz Bridge** connects Gazebo topics to ROS 2, enabling robot software to interact with the simulation as if it were real hardware.

**Key Takeaways**:
- Digital twins enable safe iteration on robot behaviors before hardware deployment
- SDF is the native format for Gazebo; URDF can be converted or used directly
- Bridge configurations must match exact topic names and message types
- Physics stability requires correct inertia, non-overlapping collisions, and appropriate friction
- Monitor real-time factor to ensure simulation keeps pace with robot control loops

---

## Knowledge Check

Test your understanding of digital twin concepts:

<Quiz
  title="Chapter 3 Quiz"
  questions={[
    {
      id: "q1",
      type: "multiple-choice",
      question: "What is the primary purpose of a digital twin in robotics?",
      options: [
        { id: "a", text: "To replace the physical robot entirely" },
        { id: "b", text: "To safely develop and test behaviors before hardware deployment" },
        { id: "c", text: "To reduce the cost of robot manufacturing" },
        { id: "d", text: "To provide remote control of physical robots" }
      ],
      correctAnswer: "b",
      explanation: "Digital twins are virtual replicas used for safe development, testing, and validation. They enable rapid iteration without risking damage to physical hardware."
    },
    {
      id: "q2",
      type: "multiple-choice",
      question: "Which SDF element is critical for physics stability?",
      options: [
        { id: "a", text: "visual geometry" },
        { id: "b", text: "material color" },
        { id: "c", text: "inertial properties (mass and inertia tensor)" },
        { id: "d", text: "topic names" }
      ],
      correctAnswer: "c",
      explanation: "Correct inertial properties (mass and inertia tensor) are essential for stable physics simulation. Incorrect values cause jittering, instability, or unrealistic behavior."
    },
    {
      id: "q3",
      type: "multiple-choice",
      question: "What does the ros_gz_bridge do?",
      options: [
        { id: "a", text: "Converts URDF to SDF format" },
        { id: "b", text: "Compiles Gazebo plugins" },
        { id: "c", text: "Connects Gazebo topics to ROS 2 topics" },
        { id: "d", text: "Renders 3D graphics" }
      ],
      correctAnswer: "c",
      explanation: "The ros_gz_bridge connects Gazebo transport topics to ROS 2 topics, enabling bidirectional communication between simulation and robot software."
    },
    {
      id: "q4",
      type: "multiple-choice",
      question: "What should you check first if your simulated robot is jittering or unstable?",
      options: [
        { id: "a", text: "Camera resolution" },
        { id: "b", text: "Network connection" },
        { id: "c", text: "Inertia values and collision geometry overlaps" },
        { id: "d", text: "Bridge configuration file" }
      ],
      correctAnswer: "c",
      explanation: "Physics instability (jittering, flying away) is typically caused by incorrect inertia values or interpenetrating collision geometries. These should be checked first."
    }
  ]}
/>

---

## Further Reading

- [Gazebo Harmonic Documentation](https://gazebosim.org/docs/harmonic) - Official Gazebo tutorials and API
- [SDF Specification](http://sdformat.org/spec) - Complete SDF format reference
- [ros_gz Repository](https://github.com/gazebosim/ros_gz) - ROS 2 integration packages
- [URDF Tutorial](https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Main.html) - ROS 2 URDF documentation

---

## Next Chapter Preview

In the next chapter, **NVIDIA Isaac & Robot Intelligence**, you will learn:
- Setting up Isaac Sim for GPU-accelerated simulation
- Importing URDF models into Isaac Sim
- Domain randomization for sim-to-real transfer
- Training reinforcement learning policies in simulation
